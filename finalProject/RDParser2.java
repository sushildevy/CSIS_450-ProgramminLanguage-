// Author: Sushil Pandey 
// Date: 05/15/2019 
// Class: CSIS 450
// Instructor: Dr. Lee
// Final Project

//Description
//This file contains the java conversion of front.java along with functions expr(), term() and factor().
//Moreover, here I added binary operators and binary assignment operators.
//This program supports the new EBNF

import java.io.*;
import java.util.*;

public class RDParser2
{ 
    //Global variable declaration:
    private static int charClass;
    private static char lexeme[];
    private static char nextChar;
    private static int lexLen;
    private static int token;
    private static int nextToken;
    private static File file;
    private static FileInputStream fInputS;
    
    private static final int LETTER=0;
    private static final int DIGIT=1;
    private static final int OPERATOR=2;
    private static final int PAREN=3;
    private static final int UNKNOWN=99;
    private static final int EOF=-1;
    private static final int INT_LIT=10;
    private static final int IDENT=11;
    private static final int ASSIGN_OP=20;
    private static final int ADD_OP=21;
    private static final int SUB_OP=22;
    private static final int MULT_OP=23;
    private static final int DIV_OP=24;
    private static final int LEFT_PAREN=25;
    private static final int RIGHT_PAREN=26;
    private static final int MOD_OP=27;
    private static final int EQUAL_OP=28;
    private static final int NOTEQUAL_OP=29;
    private static final int GREATERTHAN_OP=30;
    private static final int LESSTHAN_OP=31;
    private static final int GREATERTHANEQUAL_OP=32;
    private static final int LESSTHANEQUAL_OP=33;
    private static final int AND_OP=34;
    private static final int OR_OP=35;
    private static final int SDRIGHTSHIFT_OP=36;
    private static final int UNSRIGHTSHIFT_OP=37;
    private static final int SDLEFTSHIFT_OP=38;
    private static final int TRIHHTSHIFT_OP=39;
    
    
    //method :  expr()
    //description : this function parses in the language generated by the rule <expr> -> <term> {(+ | -) <term>}
    //function input :none
    //function output :none
    //preconditions :none
    //postconditions : calls function lex() and term()
    public static void expr()
    {
        
       System.out.print("Enter <expr>\n");
       
       term();
       
       while(nextToken==ADD_OP || nextToken==SUB_OP)
       {
            lex();
            term();
            
       }
       System.out.print("Exit <expr>\n");
       
    }

    //method :term()
    //description : parses strings in the language generated ny rule <term> -> <factor> {(* | /) <factor>) 
    //function input :none
    //function output :none
    //preconditions :
    //postconditions :calls function lex() and factor()
    public static void term()
    {
        System.out.print("Enter <term>\n");
        factor();
        while(nextToken==MULT_OP || nextToken==DIV_OP)
        {
            lex();
            factor();
           
            
        }
         System.out.print("Exit <term>\n");
    }
    
    
 
    //method :factor()
    //description : parses in the language generated by the rule <factor> -> id | int_constant | ( <expr)
    //function input :none 
    //function output :none
    //preconditions :
    //postconditions :    calls functions lex() and expr()
    public static void factor()
    {
        System.out.print("Enter <factor>\n");
        if(nextToken==IDENT || nextToken==INT_LIT)
        {
            lex();
        
            
        }
        else 
        {
            if(nextToken==LEFT_PAREN)
            {
                lex();
                expr();
                
                if(nextToken==RIGHT_PAREN)
                    lex();
                else
                    System.out.print("Error!!\n");
                
            }
            else
                System.out.print("Error!!\n");
            
        }
        System.out.print("EXit <factor>\n");
    }
    

    /***************************************************************
    function lookup
    This function look up the operators and parenthesis  in privoded file.*/
    //method :lookup()
    //description : looks up the operators and parenthesis  in privoded file
    //function input :character
    //function output :addchar() and getChar()
    //preconditions :character is provided 
    //postconditions :adds and gets characters  

    public static int lookup(char ch)
    {
        switch (ch)
        {
            case '(':
                addChar();
                getChar();
                nextToken = LEFT_PAREN;
                break;
            case ')':
                addChar();
                getChar();
                nextToken = RIGHT_PAREN;
                break;
            case '+':
                addChar();
                getChar();
                nextToken = ADD_OP;
                if(nextChar=='=')
                    {
                        addChar();
                        getChar();
                    }
                break;
            case '-':
                addChar();
                getChar();
                nextToken = SUB_OP;
                if(nextChar=='=')
                    {
                        addChar();
                        getChar();
                    }
                break;
            case '*':
                addChar();
                getChar();
                nextToken = MULT_OP;
                if(nextChar=='=')
                    {
                        addChar();
                        getChar();
                    }
                break;
            case '/':
                addChar();
                getChar();
                nextToken = DIV_OP;
                if(nextChar=='=')
                    {
                        addChar();
                        getChar();
                    }
                break;

            case '%':
                addChar();
                getChar();
                nextToken=MOD_OP;
                if(nextChar=='=')
                    {
                        addChar();
                        getChar();
                        nextToken=EQUAL_OP;
                    }
                break;

             case '&':
                addChar();
                getChar();
                nextToken=AND_OP;
                if(nextChar=='&')
                    {
                        addChar();
                        getChar();
                       
                    }
                   
                break;


                case '>':
                addChar();
                getChar();
                nextToken=GREATERTHAN_OP;
                if(nextChar=='=')
                {
                    addChar();
                    getChar();
                    
                }
                else if(nextChar=='>')
                {
                    addChar();
                    getChar();
                    if(nextChar=='>')
                    {
                        addChar();
                        getChar();
                    }
                    
                    
                }
                break;
            

            case '<':
                addChar();
                getChar();
                nextToken=LESSTHAN_OP;
                if(nextChar=='=')
                {
                    addChar();
                    getChar();
                    nextToken=EQUAL_OP;
                    
                }
                else if(nextChar=='<')
                {
                    addChar();
                    getChar();
                    nextToken=LESSTHAN_OP;
                }
                break;

            case '!':
                addChar();
                getChar();
                nextToken=NOTEQUAL_OP;
                if(nextChar=='=')
                {
                    addChar();
                    getChar();
                }
                break;


            case '|':
                addChar();
                getChar();
                nextToken=OR_OP;
                if(nextChar=='|')
                {
                    addChar();
                    getChar();
                }
                break;

            

             case '=':
                addChar();
                getChar();
                nextToken=EQUAL_OP;
                if(nextChar=='=')
                {
                    addChar();
                    getChar();
                    nextToken=EQUAL_OP;
                } 
            
            default:
                //addChar();
                //getChar();
                nextToken = EOF;
                break;
        }
        return nextToken;
    }
      

    //method : addChar()
    //description : adds the each next character to lexeme
    //function input :none
    //function output :none
    //preconditions :
    //postconditions :error message is printed if the length of character is more than 98.
    public static void addChar()
    {
            if (lexLen <= 98)
            {
                lexeme[lexLen++] = nextChar;
                lexeme[lexLen] = 0;
            }
            else
            System.out.println("Error -lexeme is too long\n");
    }
    /***************************************************************
    //function getChar
    //This function finds the next character of input and determines its character class.*/

    //method :getchar()
    //description : finds the next character of input and determines its character class
    //function input :none
    //function output :none
    //preconditions :
    //postconditions :character class is determined for each nextChar.
    public static void getChar()
    {
        try
        {
        if(fInputS.available()>0)
        {
            nextChar=(char)fInputS.read();
            if(Character.isLetter(nextChar))
                charClass=LETTER;
            else if(Character.isDigit(nextChar))
                charClass=DIGIT;
            else
                charClass=UNKNOWN;
        }
        else
            charClass=EOF;
            
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }
    }
    
    //method :getNonBlank()
    //description : calls getChar until it returns a non-whitespace character.
    //function input :none
    //function output :none
    //preconditions :
    //postconditions :getChar is called until it returns a non-whitespace character
    public static void getNonBlank()
    {
        while(Character.isSpaceChar(nextChar))
            getChar();
        
    }
    //This is a simple lexical analyzer for arithematic expressions
    public static int lex()
    {
        lexLen = 0;
            getNonBlank();
            switch (charClass)
            {
            // parse identifiers 
                case LETTER:
                    addChar();
                    getChar();
                    while (charClass == LETTER || charClass == DIGIT || charClass==OPERATOR || charClass==PAREN)
                    {
                        addChar();
                        getChar();
                    }
                    nextToken = IDENT;
                    break;
                    // parse integer literals and integers 
                case DIGIT:
                    addChar();
                    getChar();
                while(charClass == DIGIT)
                {
                        addChar();
                        getChar();
                }
                nextToken = INT_LIT;
                break;
                // parentheses and operators 

                case OPERATOR:
                    lookup(nextChar);
                    break;
                    
                case PAREN:
                    lookup(nextChar) ;
                    break;

                case UNKNOWN:
                    lookup(nextChar) ;
                    //getChar();
                    break;
                //End of file
                case EOF:
                nextToken = EOF ;
                lexeme[0] = 'E' ;
                lexeme[1] = 'O' ;
                lexeme[2] = 'F' ;
                lexeme[3] = 0;
                break ;


        } // switch statement ends here.
        
        //print statement
        if(nextToken!=EOF)
            System.out.print("Next token is :"+nextToken+" Next lexeme is ");
        else if(nextToken==EOF)
           System.out.print("Next token is :-1 Next lexeme is EOF\n");
            
        //loop iteration
        if(nextToken!=EOF)
        {
             for(int i=0;i<lexLen+1;i++){
            System.out.print(lexeme[i]);}
        System.out.println();
        }
        return nextToken;
        
    }
   
    
    //main function
    //method :main function
    //description : prints out the result
    //function input :none
    //function output :none
    //preconditions :front.in file should provided 
    //postconditions : if file does not exist, prints error message 
    public static void main(String args[])
    {
        lexLen=0;
        lexeme=new char[100];
        for(int i=0;i<100;i++)
            lexeme[i]='0';
        file = new File("front.in");
        if (!file.exists()) //checks if the file exists
        {
                System.out.println( "file front.in does not exist."); //print of error message 
                return;
        }
      
        //try catch block  
        else{
        try
        {     
                fInputS = new FileInputStream(file); 
                char current;
                getChar();
                //do-while loop
                do
                {
                    
                    lex();
                    expr();
                }while (fInputS.available()>0);
                
        }
        catch (IOException e)
        {
                e.printStackTrace();
        }
        
        }
    }
    }
